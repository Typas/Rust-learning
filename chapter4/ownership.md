# 4.1 What is Ownership? 所有權是什麼

## 第4章簡介
所有權是Rust最獨特的特性，而且它讓Rust能不用自動記憶體回收(garbage collector)也能確保記憶體的安全性。所以，理解Rust裡所有權如何運作很重要。

## What is Ownership? 所有權
所有權是Rust的中心特性。雖然這個特性解釋起來很直白，但是在其他語言中有深入的實作。

首先，所有的程式在執行時都會用到電腦的記憶體，而且需要一套管理記憶體的方法。有些語言有自動的記憶體回收機制，讓它寫起來像是不需要記憶體一樣；其他的語言裡，程式設計師則需要明確配置跟釋放記憶體。Rust採用了第三種方式：記憶體由一個有規則的所有權系統管理。這套規則能讓編譯器在編譯時檢查，不讓所有權這個特性成為拖慢程式的原因。

因為所有權對許多程式設計師來說是個嶄新的概念，所以需要點時間來適應。當你理解了之後，你會有堅實的基礎來了解讓Rust獨特的一些特性。在這章，會以一個非常常見的資料結構來學習所有權：字串(string)。

### The Stack and the Heap 堆疊與堆積
有學過C或C++的應該都清楚，這段可以跳過。
在許多的程式語言裡，你不需要常常想到堆疊跟堆積。但是對像Rust這樣的系統程式語言，要在堆積還是堆疊存值取決於語言的行為與你決定怎麼做。在這章的後面會描述堆疊與堆積的關係，這邊會先做簡要說明。

堆疊與堆積都是記憶體中能讓程式在執行時使用的部份，但是構建的方法不同。堆疊以取得值的順序來儲存，再以逆序移除。這被稱為last in, first out。像是一疊的盤子：當你把盤子疊上去時，你把新盤子放在盤子堆的最上面，而拿走時則從最上面拿。從中間或最下面放或拿盤子是不可行的！加入資料被稱為推入堆疊(pushing onto the stack)，而移出資料被稱為移出堆疊(popping off the stack)。

所有放在堆疊上的資料必須要有一個已知且固定的大小。在編譯時未知大小或是大小會變動的資料應該被存在堆積裡。堆積結構比較鬆散：當你想放資料進堆積時，會先要求一個大小的空間，作業系統會找個堆積上有夠大空位的地方，在起始點作個使用中的標記，然後用記錄空間位置的指標(pointer)回傳起始點。這個過程被稱為在堆積上配置(allocating on the heap)，有時被縮寫成配置(allocating)。把值放到堆積上不是配置。因為指標是個已知且固定大小的東西，所以能把指標存在堆疊上，但是當想要實際的資料時，你需要操作指標。

想像一個有許多座位的餐廳。當進門時，你會說這群人有多少個，然後服務生會找到一個能容納團體所有人的空桌子，且帶你們過去。如果有人遲到了，報個名字就可以讓服務生帶路了。

推入堆疊會比在堆積上配置還要快，因為都會放在最上面，所以不需要找一個能放新資料的地方。相對來說，在堆積上配置空間比較費工，因為作業系統要找到一塊夠大的空間來放資料，再記錄下來以準備下次的配置。

存取在堆積上的資料也比存取在堆疊上的慢，因為你需要以指標間接存取。現在的處理器在記憶體位址跳躍不大的時候會比較快。繼續上面的餐廳比喻，想像餐廳有一台處理多桌點餐單的伺服器。從一張桌子上拿桌上所有的點餐單再移到下一張桌子會最有效率，從A桌上拿一張單子，再從B桌上拿一張，再回A桌拿一張，然後在B桌拿一張的方式會比前面的方式慢很多。同理，處理器如果能從近一點的地方拿資料，會比從遠的地方拿還要更好。在堆積上配置一大塊空間也會花一段時間。

當你的程式呼叫了一個函式時，參數會傳進函式裡成為區域變數，而且函式的區域變數會推入堆疊中。當函式結束時，這些都會被移出堆疊。

持續追蹤哪些程式碼用了在堆積上的資料，最小化堆積上的重複資料，清除堆積上的無用資料以防空間不足，這些是所有權應付的問題。當你理解了所有權後，你不再需要常常想堆疊與堆積，不過知道所有權是為了管理堆積上的資料，就能幫助解釋所有權的做法是為了什麼。

## Ownership Rules 所有權規則
首先，來看一下所有權的規則。在後面的範例中記住這些規則：
- 每個在Rust中有值的變數叫作所有者(owner)。
- 同時只能有一個所有者。
- 當所有者不在變數範疇時，值會被捨棄。

## Variable Scope 變數範疇
在第二章時已經有個Rust程式的示範。現在我們有了基本語法，範例不再特別寫出`fn main() {}`，所以當你實作的時候，請將程式碼放入`main`函式。這樣能精簡一點，不用再寫整個模板。

第一個所有權的例子，來看看變數的範疇(scope)。範疇是程式中一個東西有效的範圍。例如我們有個長這樣的變數：
``` rust
let s = "hello";
```
變數`s`指向了程式中一個被寫死的文字字串。這個變數從它被宣告開始，到現在的範疇結束為止有效。Listing 4-1 有註解哪邊是變數`s`的有效範圍。

> Listing 4-1
``` rust
{
    // s在這裡無效，它還沒被宣告
    let s = "hello"; // s從這裡開始有效
    // 在這處理與s有關的東西
}   // 範疇在此結束，s從此不再有效
```

換個說法，這裡有兩個重要的時間點：
- 當`s`宣告進範疇後，它有效。
- 它會一直有到到離開範疇

在這個地方，範疇間的關係與變數什麼時候有效與其他語言相似。現在我們以這為基礎介紹`String`這個型態。

## The `String` Type `String`型態
我們需要一個，比第三章的「資料型態」中介紹的更複雜的資料型態，來講解所有權的規則。因為這些基本的資料型態都會存在堆疊中，在範疇結束時被直接移出堆疊，但是我們想要一個會把資料存在堆積上的型態，來了解Rust什麼時候會清掉資料。

我們在例子裡會用到`String`這個字串型態，而且會專注在`String`部分的所有權上。其他標準函式庫與自建的複雜資料型態，也適用這個所有權概念。在第八章會更深入討論`String`。

我們已經看過了文字字串，也就是一個在程式碼中寫死的字串值。文字字串很方便，但是不適用於所有想用到字串的情況。其中一個原因是它們不可動，另一個原因是不是所有的字串值都能被預知的。舉個例子，如果想讓使用者輸入字串並儲存它？為了對應這種情況，Rust有第二種的字串型態：`String`。這個型態會在堆積上配置記憶體，而且能夠存在編譯時未知數量的文字。你可以從文字字串中用`from`函式來建立一個`String`變數，例如：
``` rust
let s = String::from("hello");
```

雙冒號`::`是一個能讓我們從`String`型態的命名空間中使用裡面的`from`函式的運算子，好過用一些像是`string_from`的函數命名。這語法會在第五章的Method Syntax中討論，而命名空間(namespace)則會在第七章的Paths for Referring to an Item in the Module Tree中討論。

這種型態的字串是能被改動的：
``` rust
let mut s = String::from("hello");

s.push_str(", world!"); // push_str() 把文字加掛在字串後面

println!("{}", s); // 這會印出 `hello, world!`
```

所以，這差別在哪？為什麼`String`變數可以改動但是文字字串不行？這差別在這兩種型態的記憶體使用方式不同。

## Memory and Allocation 記憶體與配置
對於文字字串，我們在編譯的時候就知道了內容，所以文字是直接寫死在最後的執行檔內，這就是文字字串會快又有效的原因。但是這些特點是從文字字串的不可變性來的。很不幸，我們沒辦法對每一個不能在編譯時確定大小的字串都放固定的記憶體大小，這些字串可能會變動它的大小。

為了要有一個能改內容，能改變文字數量的`String`型態，我們需要在堆積中配置一塊記憶體，在編譯時未知大小，且能保存文字內容。這也代表了：
- 記憶體必須在執行時從作業系統中要求。
- 我們需要一個能在`String`做完它的事時歸還記憶體給作業系統的方法。

第一部分我們已經用過了：當我們呼叫了`String::from`時，它會向作業系統請求記憶體。這是程式語言中很普遍的行為。

但是，第二部分在不同語言中有不同的處理方法。在有自動記憶體回收器(garbage collector)的語言中，回收器會持續追蹤，且清理不再使用的記憶體，我們不需要考慮它需不需要被還給作業系統。沒有回收器的情況下，分辨記憶體何時不再使用並明確的以程式碼來歸還給作業系統是我們的責任，就像要求時一樣。要把這個做得正確在歷史上是個程式難題。如果我們忘了，會浪費記憶體。如果太早還，我們會有個無效的變數。如果還了兩次，也是一個bug。我們需要一個`allocate`剛剛好配到一個`free`。

Rust走了不同的路：當擁有記憶體的變數離開它的範疇時，記憶體會被自動歸還。這邊有一個Listing 4-1的改版，把文字字串用`String`取代：
``` rust
{
    let s = String::from("hello"); // s從這裡開始有效
    
    // 在這處理與s有關的東西
} // 範疇在此結束，s不再有效
```

我們可以在一個很自然的點上，將`String`跟作業系統要的記憶體還回去：當`s`離開範疇時。當一個變數離開範疇時，Rust會為我們呼叫一個特殊函式。這函式叫`drop`，而且可以在程式碼中呼叫`drop`來歸還記憶體。Rust在大括號的結束會自動呼叫`drop`。

> 在C++中，這種在一個物件的生命期結束時解除配置的模式有時被稱作Resource Acquisition Is Initialization (RAII)。Rust的`drop`函式會很像RAII模式。

這個模式對Rust的程式碼寫作方式有深刻的影響。這現在看起來很簡單，但是在更複雜的情況中程式碼的行為可能會出乎意料，像是需要多個變數來使用存在堆積上的資料時。現在讓我們來探索一下這些情況。

### Ways Variable and Data Interact: Move 變數與資料的互動方式：移動
Rust中多個變數可以用不一樣的方式來與同一筆資料互動。讓我們來看個例子：

> Listing 4-2: 對變數`y`以變數`x`賦予一個整數值
``` rust
let x = 5;
let y = x;
```

我們可能猜到了這在做什麼：「把`5`這個值綁到`x`上；然後複製`x`的值之後綁到`y`上。」我們現在有兩個變數`x`和`y`，兩個都等於`5`。這確實是這麼發生的，因為整數是個我們已知且固定大小的值，且兩個`5`的值都會被推到堆疊上。

現在來看一下`String`版本：
``` rust
let s1 = String::from("hello");
let s2 = s1;
```

這看起來跟前面的程式碼非常像，所以我們可能假設這行為也是一樣的：第二行會做出一個`s1`的值的複製品再綁到`s2`上。不過不會在這發生。

讓我們看一下Figure 4-1以了解`String`底下發生了什麼。一個`String`由三個部份組成，顯示在左邊：一個指向有字串內容的指標，長度與容量。這組資料會存在堆疊上。右邊則是在堆積中實際存內容的記憶體部份。
![Figure 4-1](https://doc.rust-lang.org/book/img/trpl04-01.svg)
> Figure 4-1: 綁在`s1`有內容`"hello"`的`String`在記憶體上的表示

長度`len`代表`String`的內容中有多少記憶體正在使用中。容量`capacity`是`String`從作業系統得到的記憶體總量，單位是位元組(byte)。長度跟容量兩者的意義有很重要的不同，但是不會在這裡提，所以現在可以先忽略掉容量。

當我們把`s1`指派給`s2`時，`String`的資料會被複製，這代表我們把指標、長度與容量這三個在堆疊上的變數都複製了。我們不會複製指標指向的，堆積上那些資料。換句話說，在記憶體中資料的表示會看起來像Figure 4-2。
![Figure 4-2](https://doc.rust-lang.org/book/img/trpl04-02.svg)
> Figure 4-2: 從`s1`複製指標、長度與容量的變數`s2`在記憶體上的表示

這記憶體上的表示長得不像Figure 4-3，假設Rust會把所有在堆積上的資料也複製過去。如果Rust這樣做，`s2 = s1`這個運算如果堆積上的資料很大，對執行的效能來說會變得很貴。
![Figure 4-3](https://doc.rust-lang.org/book/img/trpl04-03.svg)
> Figure 4-3: 另一種`s1 = s2`的可能性，如果Rust會也複製堆積上的資料

之前我們講到當一個變數離開範疇時，Rust會自動呼叫`drop`函式且清除該變數在堆積上的記憶體。但是Figure 4-2顯示兩個指標都會指到同個地方。這就有個問題：當`s2`與`s1`離開範疇時，它們都會試著釋放同一塊記憶體。這被稱為雙重釋放(double free)錯誤，也是一個之前提過的記憶體安全性bug。釋放記憶體兩次會導致記憶體腐壞(memory corruption)，這可能導致安全性漏洞的產生。

為了要確保記憶體安全性，這邊還有一個Rust在這種情況會有的細節。Rust會認為`s1`己經不再有效，且在`s1`離開範疇時不會再釋放任何東西，而不是試著把堆積上配置的記憶體內容複製過來。檢查當`s2`建立之後，再用`s1`會發生什麼事。它會出錯：
``` rust
let s1 = String::from("hello");
let s2 = s1;

println!("{}, world!", s1);
```
錯誤訊息在編譯時會出現。

如果你在其他語言中有聽過淺複製(shallow copy)與深複製(deep copy)，上面只複製指標、長度與容量的概念聽起來像是做一次淺複製。不過因為Rust無效化了第一個變數，所以這個不叫淺複製，而叫作移動(move)。在這個例子中，我們會說`s1`被移動到`s2`了。所以實際發生的事是Figure 4-4的圖。
![Figure 4-4](https://doc.rust-lang.org/book/img/trpl04-04.svg)
> Figure 4-4: 當`s1`被無效化後記憶體中的表示

這解決了雙重釋放的問題！當只有`s2`有效，在它離開範疇時，它會單獨釋放記憶體。除此之外，還有一個設計上的選擇：Rust永遠不會自動對你的資料做「深」複製。所以，任何自動的複製都可以當成在執行時不會耗用大量資源。

### Ways Variable and Data Interact: Clone 變數與資料的互動方式：仿製
如果我們真的想要深複製一份`String`在堆積的資料，而不是只有堆疊上的資料，我們可以用一種叫`clone`的常見方法。我們會在第五章討論到方法(method)的語法，但因為方法是很多程式語言會有的特性，你可能在之前就看過了。這裡有個使用`clone`的例子：
``` rust
let s1 = String::from("hello");
let s2 = s1.clone();

println!("s1 = {}, s2 = {}", s1, s2);
```

這運作順利而且明確做到了Figure 4-3所展示的行為，也就是堆積上的東西也被複製了。

當你看到一個`clone`呼叫，你會知道有些程式碼被執行了，而且那段程式碼可能很貴，消耗了大量資源。這是一個能顯示不同複製行為的目視指示器。

### Stack-Only Data: Copy 僅在堆疊上的資料：複製
還有個小地方還沒談到。Listing 4-2的部份程式碼用了整數的複製，但它一樣有著良好且有效的運作：
``` rust
let x = 5;
let y = x;

println!("x = {}, y = {}", x, y);
```

但是這段程式碼看起來跟前面學的衝突：我們不用呼叫`clone`，而`x`還是有效而且沒有被移動給`y`。

原因是這些在編譯期已知大小的型態，像是整數，是被存在堆疊上的，所以把實際的值複製過來很快。這代表我們沒有理由去防止`x`在宣告`y`之後繼續有效存在。換句話說，這邊不會有淺複製與深複製的差別，所以呼叫`clone`並不會跟正常的淺複製有什麼差異，所以可以不管它。

Rust有個特別的標記稱為`Copy`特質(trait)，讓我們可以把像是整數的型態放在堆疊上。如果一個型態有`Copy`特質，複製過的舊變數還是能用。Rust不會允許有實作`Drop`特質的一個型態，或它的一部分有實作，能以`Copy`特質來標記。如果這個型態需要在離開變數範疇還能存取到值，而我們加了`Copy`標記上去，我們會得到一個編譯錯誤。想了解怎麼加上`Copy`標記，請見Appendix C的"Derivable Traits"。

所以有哪些是`Copy`的型態？你可以查看型態的說明來確認，不過有個通則，所有簡單的純量型態的組合都可以有`Copy`標記，而完全沒有配置記憶體或是是某種型態的資源也是`Copy`。這裡有一些是`Copy`的型態：
- 所有的整數型態，像是`u32`。
- 布林型態`bool`，有值`true`及`false`。
- 所有的浮點數型態，像是`f64`。
- 字元型態`char`。
- 數值組，如果只含也是`Copy`型態的。舉例來說，`(i32, i32)`是`Copy`，但是`(i32, String)`不是。

## Ownership and Functions 所有權與函式
傳遞一個值給函式的語義與賦予一個值給變數很相似。傳遞一個變數給函式會移動或複製，就像賦值一樣。Listing 4-3有個有展示變數如何進入與離開範疇的註解的例子。
``` rust
fn main() {
    let s = String::from("hello"); // s進入範疇
    
    takes_ownership(s);            // s的值移動進函式...
                                   // ...而且在這不再有效
    
    
    let x = 5;                     // x進入範疇
    
    makes_copy(x);                 // x應該移入函式，但是i32是Copy，
                                   // 所以x在這之後還是能用
} // 這裡，x離開範疇，然後是s。但是因為s的值被移動了，不會發生什麼事。

fn takes_ownership(some_string: String) { // some_string進入範疇
    println!("{}", some_string);
} // 這裡，some_string離開範疇且呼叫`drop`。堆積上的記憶體被釋放。

fn makes_copy(some_integer: i32) { // some_integer進入範疇
    println!("{}", some_integer);
} // 這裡，some_integer離開範疇，沒什麼特別的事發生
```
> Listing 4-3: 標注所有權與範疇的函式

## Return Values and Scope 回傳值與變數範疇
回傳值也能轉移所有權。Listing 4-4是一個跟Listing 4-3註解相似的例子。
``` rust
fn main() {
    let s1 = gives_ownership();         // gives_ownership() 把它回傳值的所有權給s1
    
    let s2 = String::from("hello");     // s2進入範疇
    
    let s3 = takes_and_gives_back(s2);  // s2被移進takes_and_gives_back，
                                        // 而函式移動其回傳值給s3
} // 這裡，s3離開範疇並呼叫`drop`。s2離開範疇但被移動，所以沒事。s1離開範疇並呼叫`drop`。

fn gives_ownership() -> String {             // gives_ownership會移動它的回傳值
                                             // 給呼叫它的函式
    let some_string = String::from("hello"); // some_string進入範疇
    
    some_string                              // 回傳some_string並移動給呼叫它的函式
}

// takes_and_gives_back會拿走一個String並回傳一個
fn takes_and_gives_back(a_string: String) -> String { //a_string進入範疇
    a_string // 回傳a_string並移動給呼叫它的函式
}
```
> Listing 4-4: 以回傳值轉移所有權

變數的所有權隨時遵守一樣的模式：在賦值給另一個變數時進行移動。當有一個包含了堆積上資料的變數離開範疇時，這個值除非有移動給其他變數，否則會被`drop`清除。

在每個函式都拿所有權再還回去有點無聯。如果我們想讓一個函式使用一個值但是不拿走其所有權呢？所有我們傳過去的變數想再利用的話，就得傳回來，還加上任何從函式中得到的資料也要回傳。

用數值組回傳多個值是可能的，如Listing 4-5所示。
``` rust
fn main() {
    let s1 = String::from("hello");
    
    let (s2, len) = calculate_length(s1);
    
    println!("The length of '{}' is {}.", s2, len);
}

fn calculate_length(s: String) -> (String, usize) {
    let length = s.len(); // len()回傳String的長度
    
    (s, length)
}
```
> Listing 4-5: 回傳參數的所有權

不過這很冗長，而且對一個常用到的概念來說太費事了。我們很幸運，Rust有個對應這概念的特性，叫作參考(references)。

# Links
- 下一章節 - 4.2 [References and Borrowing](./reference.md)
- 回到[目錄](./../README.md)

## References
- *String* [Storing UTF-8 Encoded Text with Strings] 尚未完工
- 5.3 [Method Syntax] 尚未完工
- 7.2 [The Module System to Control Scope and Privacy] 尚未完工
- 21.3 [Appendix C] 尚未完工
