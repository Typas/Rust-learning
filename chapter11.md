# Notes

## 測試重點

1. 設定任何的資料或狀態。
2. 執行想測試的程式碼。
3. 斷定結果是你所預想的。

`cargo test`是執行測試的指令。

## 測試的組成

### 單元測試

- 在模組前的`#[cfg(test)]`會讓模組成為一個測試模組。
- 需放在被測模組的檔案中。
- 常在測試模組的開頭用`use super::*`來省略被測模組的路徑。
- 可測試位於同檔案中的私有函數。

### 整合測試

- 不在library中，測試環境與一般使用相同。
- 位置是`$PROJECT_DIR/tests/`，所有位於此的檔案都會被當成測試crate。
- 若要在測試環境中設定共同的環境，可以在`tests/`內建立一個內含`mod.rs`的目錄如`name`，再在其他模組內使用`mod name;`與`name::common_setup()`來達成設定。

### 文件測試

- 這是用來測試rustdoc中的所有範例程式是否能執行與是否符合現行版本的情況。

### 測試順序

執行測試會先進行單元測試，再進行整合測試，最後進行文件測試。

## 測試函數的組成

### 屬性

- 在函數前的`#[test]`會讓函數成為一個測試函數。
- 在測試函數前的`#[should_panic]`讓函數在`panic!()`時通過測試，而在沒有`panic!()`時失敗。
- 在測試函數前的`#[ignore]`會讓函數在預設條件下不會執行測試。

### 斷言

- `assert!()`：判斷式為`true`時通過，為`false`時則`panic!()`。
- `assert_eq!()`：左右相等時通過，不相等時則`panic!()`。
- `assert_ne!()`：左右不等時通過，相等時則`panic!()`。

斷言巨集在必要參數後能以格式化字串取得自訂的`panic!()`訊息。

### 回傳錯誤

可以用回傳`Result<(),String>`取代`panic!()`，可以使用`?`來自動回傳`Err`。
但是這樣就不能使用到斷言與`#[should_panic]`。

## 執行測試

### 執行方式

- 平行化處理：預設值，會用多執行緒同時跑多個測試，所以需要確保沒有任何的資料競爭。
- 連續處理：在有競爭資源的關係時，可以用以下指令確保不會有資料競爭而發生的錯誤。
``` sh
cargo test -- --test-threads=1
```

### 函數中的輸出

- 不顯示：預設值，所有的`println!()`等巨集或函數的輸出會被捨棄，螢幕只顯示通過測試與否。
- 顯示：會顯示所有測試的函數中所有的輸出。
``` sh
cargo test -- --show-output
```

### 執行特定測試

- 所有測試：預設值。
- 特定測試：測試函數的名字有包含關鍵字(如下為`keyword`)時執行。
``` sh
cargo test keyword
```
- 被忽略的：有`ignored`屬性的測試函數可用以下指令執行，通常為耗時較久的測試。
``` sh
cargo test -- --ignored
```
